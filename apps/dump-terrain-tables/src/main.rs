// This file is part of OpenFA.
//
// OpenFA is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// OpenFA is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with OpenFA.  If not, see <http://www.gnu.org/licenses/>.
use failure::Fallible;
use nalgebra::Vector2;
use std::{
    cmp::Ordering,
    collections::{HashMap, HashSet},
    fmt,
};
use structopt::StructOpt;

#[derive(Debug, StructOpt)]
#[structopt(
    name = "dump-terrain-tables",
    about = "Build tables that we need for rendering."
)]
struct Opt {
    /// Dump all triangle strips.
    #[structopt(short, long)]
    strips: bool,

    /// Dump all index dependency LUTs
    #[structopt(short, long)]
    luts: bool,

    /// Select the max subdivision depth to dump.
    #[structopt(short, long, default_value = "9")]
    max_level: usize,
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
struct Edge {
    a: u32,
    b: u32,
}

impl Edge {
    fn new(i0: u32, i1: u32) -> Self {
        if i0 < i1 {
            Self { a: i0, b: i1 }
        } else {
            Self { a: i1, b: i0 }
        }
    }
}

impl fmt::Display for Edge {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.a, self.b,)
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq)]
struct Triangle {
    v: [Vector2<i64>; 3],
    i: [u32; 3],
}

impl Triangle {
    fn new(
        i0: u32,
        v0: Vector2<i64>,
        i1: u32,
        v1: Vector2<i64>,
        i2: u32,
        v2: Vector2<i64>,
    ) -> Self {
        Self {
            v: [v0, v1, v2],
            i: [i0, i1, i2],
        }
    }

    fn leftmost(&self) -> i64 {
        let a = self.v[0][0];
        let b = self.v[1][0];
        let c = self.v[2][0];
        a.min(b).min(c)
    }

    fn rightmost_index(&self) -> u32 {
        // Note: we are never aligned on x, so picking one can select the index.
        let a = self.v[0][0];
        let b = self.v[1][0];
        let c = self.v[2][0];
        let v = a.max(b).max(c);
        if v == a {
            self.i[0]
        } else if v == b {
            self.i[1]
        } else {
            assert_eq!(v, c);
            self.i[2]
        }
    }
}

impl fmt::Display for Triangle {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "T[{}:({:0.2},{:0.2}),{}:({:0.2},{:0.2}),{}:({:0.2},{:0.2})]",
            self.i[0],
            self.v[0][0],
            self.v[0][1],
            self.i[1],
            self.v[1][0],
            self.v[1][1],
            self.i[2],
            self.v[2][0],
            self.v[2][1]
        )
    }
}

impl Ord for Triangle {
    fn cmp(&self, other: &Self) -> Ordering {
        self.leftmost().cmp(&other.leftmost())
    }
}

impl PartialOrd for Triangle {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

// Note: this only has to line up with whatever we do in subdivide, not patch_tree, thankfully.
fn main() -> Fallible<()> {
    let opt = Opt::from_args();

    if opt.strips {
        make_strips(opt.max_level);
    }

    if opt.luts {
        make_index_dependency_luts(opt.max_level);
    }

    Ok(())
}

fn make_strips(max_level: usize) {
    println!("// //////////////////////////////// AUTOGENERATED DEPS //////////////////////////////// //");
    println!("// cargo run -p terrain_geo --example make-strips");
    for i in 0..=max_level {
        let (tris, _deps) = make_tris(i);
        let bins = collect_unique_rows(&tris);
        let binned = bin_by_row(&tris);
        // for bin in bins.iter().rev() {
        //     println!("  bin: {:?}", bin);
        //     for t in &binned[bin] {
        //         println!("    {}", t);
        //     }
        // }
        let indices = make_strip(&bins, &binned, 0);
        println!("INDICES: {:?}", indices);
    }
    println!("// ////////////////////////////// END AUTOGENERATED DEPS ////////////////////////////// //");
}

fn make_index_dependency_luts(max_level: usize) {
    println!("// //////////////////////////////// AUTOGENERATED DEPS //////////////////////////////// //");
    println!("// cargo run -p terrain_geo --example make-strips");
    for i in 0..=max_level {
        let (_tris, deps) = make_tris(i);
        println!(
            "pub const INDEX_DEPENDENCY_LUT{}: [u32; {}] = [\n    {}\n];",
            i,
            deps.len() * 2,
            deps.iter()
                .map(|e| format!("{},\n    {}", e.a, e.b))
                .collect::<Vec<_>>()
                .join(",\n    ")
        );
    }
    println!("// ////////////////////////////// END AUTOGENERATED DEPS ////////////////////////////// //");
}

fn make_strip(
    bins: &[(i64, i64)],
    binned: &HashMap<(i64, i64), Vec<Triangle>>,
    winding: u8,
) -> Vec<u32> {
    let mut indices = Vec::new();

    for bin in bins.iter().rev() {
        println!(
            "BIN: {:?}: {:?}",
            bin,
            binned[bin].iter().map(|t| t.i).collect::<Vec<_>>()
        );
        // Start off each row with the left two verts after resetting.
        let fst = binned[bin].first().unwrap();
        indices.push(fst.i[0]);
        indices.push(fst.i[1]);
        for tri in &binned[bin] {
            indices.push(tri.rightmost_index());
        }
    }

    indices
}

fn bin_by_row(tris: &[Triangle]) -> HashMap<(i64, i64), Vec<Triangle>> {
    let row_bins = collect_unique_rows(tris).drain(..).collect::<HashSet<_>>();
    let mut bins: HashMap<(i64, i64), Vec<Triangle>> = HashMap::new();
    for t in tris {
        let bin = row_bin_for_tri(t);
        assert!(row_bins.contains(&bin));
        bins.entry(bin)
            .and_modify(|v| v.push(*t))
            .or_insert_with(|| vec![*t]);
    }

    // Sort bins by leftmost coordinate.
    for tris in bins.values_mut() {
        tris.sort();
    }

    bins
}

fn row_bin_for_tri(tri: &Triangle) -> (i64, i64) {
    let a = tri.v[0][1];
    let b = tri.v[1][1];
    let c = tri.v[2][1];
    if a == c {
        assert_ne!(b, a);
        assert_ne!(b, c);
        if a < b {
            (a, b)
        } else {
            (b, a)
        }
    } else if b == c {
        assert_ne!(a, b);
        assert_ne!(a, c);
        if a < c {
            (a, c)
        } else {
            (c, a)
        }
    } else {
        assert_eq!(a, b);
        assert_ne!(c, a);
        assert_ne!(c, b);
        if a < c {
            (a, c)
        } else {
            (c, a)
        }
    }
}

fn collect_unique_rows(tris: &[Triangle]) -> Vec<(i64, i64)> {
    let mut uniq = HashSet::new();
    for t in tris {
        uniq.insert(t.v[0][1]);
        uniq.insert(t.v[1][1]);
        uniq.insert(t.v[2][1]);
    }
    let mut v = uniq.drain().collect::<Vec<i64>>();
    v.sort();
    (&v).windows(2).map(|v| (v[0], v[1])).collect::<Vec<_>>()
}

fn count_unique_vertices(tris: &[Triangle]) -> usize {
    let mut uniq = HashSet::new();
    for t in tris {
        uniq.insert(t.v[0]);
        uniq.insert(t.v[1]);
        uniq.insert(t.v[2]);
    }
    uniq.len()
}

fn make_tris(subdivisions: usize) -> (Vec<Triangle>, Vec<Edge>) {
    let s = 100 * (subdivisions + 1) as i64;
    let v0 = Vector2::new(0, s);
    let v1 = Vector2::new(-s, -s);
    let v2 = Vector2::new(s, -s);
    let tri = Triangle::new(0, v0, 1, v1, 2, v2);
    let mut indices = HashMap::new();
    indices.insert(v0, (0, Edge::new(u32::MAX, u32::MAX)));
    indices.insert(v1, (1, Edge::new(u32::MAX, u32::MAX)));
    indices.insert(v2, (2, Edge::new(u32::MAX, u32::MAX)));
    let mut deps_lut = HashMap::new();
    deps_lut.insert(0, Edge::new(u32::MAX, u32::MAX));
    deps_lut.insert(1, Edge::new(u32::MAX, u32::MAX));
    deps_lut.insert(2, Edge::new(u32::MAX, u32::MAX));
    let mut tris = vec![];
    for target in 0..=subdivisions {
        subdivide_tris_inner(
            target,
            0,
            subdivisions,
            tri,
            &mut tris,
            &mut indices,
            &mut deps_lut,
        );
    }

    assert_eq!(deps_lut.len(), count_unique_vertices(&tris));
    let mut deps = Vec::new();
    for i in 0u32..deps_lut.len() as u32 {
        deps.push(deps_lut[&i]);
    }

    (tris, deps)
}

fn get_index(
    active: bool,
    v: &Vector2<i64>,
    edge: Edge,
    indices: &mut HashMap<Vector2<i64>, (u32, Edge)>,
    deps_lut: &mut HashMap<u32, Edge>,
) -> u32 {
    if let Some(&(index, existing_edge)) = indices.get(v) {
        assert_eq!(edge, existing_edge);
        return index;
    }
    let index = indices.len() as u32;
    if active {
        indices.insert(*v, (index, edge));
        deps_lut.insert(index, edge);
    }
    index
}

fn subdivide_tris_inner(
    target_level: usize,
    level: usize,
    max_level: usize,
    tri: Triangle,
    tris: &mut Vec<Triangle>,
    indices: &mut HashMap<Vector2<i64>, (u32, Edge)>,
    deps_lut: &mut HashMap<u32, Edge>,
) {
    let active = level == target_level;

    if level >= max_level {
        if active {
            tris.push(tri);
        }
        return;
    }

    // Subdivide tri and head down.
    let v0 = tri.v[0];
    let v1 = tri.v[1];
    let v2 = tri.v[2];
    let i0 = tri.i[0];
    let i1 = tri.i[1];
    let i2 = tri.i[2];
    let a = (v0 + v1) / 2;
    let ia = get_index(active, &a, Edge::new(i0, i1), indices, deps_lut);
    let b = (v1 + v2) / 2;
    let ib = get_index(active, &b, Edge::new(i1, i2), indices, deps_lut);
    let c = (v2 + v0) / 2;
    let ic = get_index(active, &c, Edge::new(i2, i0), indices, deps_lut);
    subdivide_tris_inner(
        target_level,
        level + 1,
        max_level,
        Triangle::new(i0, v0, ia, a, ic, c),
        tris,
        indices,
        deps_lut,
    );
    subdivide_tris_inner(
        target_level,
        level + 1,
        max_level,
        Triangle::new(ia, a, i1, v1, ib, b),
        tris,
        indices,
        deps_lut,
    );
    subdivide_tris_inner(
        target_level,
        level + 1,
        max_level,
        Triangle::new(ic, c, ib, b, i2, v2),
        tris,
        indices,
        deps_lut,
    );
    subdivide_tris_inner(
        target_level,
        level + 1,
        max_level,
        Triangle::new(ib, b, ic, c, ia, a),
        tris,
        indices,
        deps_lut,
    );
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_uniq_verts() {
        let mut all_deps = Vec::new();
        for i in 0..7 {
            let (_tris, deps) = make_tris(i);
            all_deps.push(deps);
        }
        for pair in all_deps.windows(2) {
            let a = &pair[0];
            let b = &pair[1];
            for (i, e) in a.iter().enumerate() {
                assert_eq!(*e, b[i]);
            }
        }

        for i in 0..9 {
            let (tris, deps) = make_tris(i);
            let expect = (((2f64.powf(i as f64) + 1f64) * (2f64.powf(i as f64) + 2f64)) / 2f64)
                .floor() as usize;
            assert_eq!(count_unique_vertices(&tris), expect);
        }
    }
}
